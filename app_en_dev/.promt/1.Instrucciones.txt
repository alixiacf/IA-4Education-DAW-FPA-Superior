/chatbot
├── /public
│   ├── styles.css
│   ├── script.js
│   └── index.html
├── server.js
├── package.json
└── README.md


Step 2: Create package.json
In the root of your project directory, create a package.json file to manage dependencies:

npm install express path ollama cors
npm init -y
Step 3: Create the Server with server.js
Create the server.js file in the root of your project directory:

const express = require('express');
const path = require('path');
const { Ollama } = require('ollama');
const cors = require('cors');

const app = express();
const port = process.env.PORT || 3000;

const ollama = new Ollama({
    url: 'http://localhost:11434'
});

app.use(cors());
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// Middleware to log requests
app.use((req, res, next) => {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);
    next();
});

// Error handling middleware 
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ error: 'Something went wrong!' });
});

app.get('/models', async (req, res) => {
    try {
        const modelList = await ollama.list();
        res.json(modelList);
    } catch (error) {
        console.error("Error fetching models:", error);
        res.status(500).json({ error: 'Failed to fetch models' });
    }
});

app.post('/chat', async (req, res) => {
    const { model, messages, stream = false } = req.body;

    if (!model || !messages) {
        return res.status(400).json({ error: 'Missing required parameters' });
    }

    try {
        if (stream) {
            res.writeHead(200, {
                'Content-Type': 'text/event-stream',
                'Cache-Control': 'no-cache',
                'Connection': 'keep-alive'
            });

            const chatResponse = await ollama.chat({
                model,
                messages,
                stream: true
            });

            for await (const chunk of chatResponse) {
                res.write(`data: ${JSON.stringify(chunk)}\n\n`);
            }
            res.end(); 

        } else {
            const response = await ollama.chat({
                model,
                messages
            });
            res.json({ response: response.message.content }); 
        }
    } catch (error) {
        console.error("Error during chat:", error);
        res.status(500).json({ error: 'Chat request failed' });
    }
});

app.post('/generate', async (req, res) => {
    const { model, prompt } = req.body;

    if (!model || !prompt) {
        return res.status(400).json({ error: 'Missing required parameters' });
    }

    try {
        const response = await ollama.generate({ model, prompt }); 
        res.json(response);
    } catch (error) {
        console.error("Error generating text:", error);
        res.status(500).json({ error: 'Text generation failed' });
    }
});

app.post('/embeddings', async (req, res) => {
    const { model, input } = req.body;

    if (!model || !input) {
        return res.status(400).json({ error: 'Missing required parameters' });
    }

    try {
        const response = await ollama.embed({ model, input });
        res.json(response);
    } catch (error) {
        console.error("Error generating embeddings:", error);
        res.status(500).json({ error: 'Embedding generation failed' });
    }
});

app.get('/health', (req, res) => {
    res.status(200).json({ status: 'OK' });
});

const server = app.listen(port, () => {
    console.log(`Server running at http://localhost:${port}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
    console.log('SIGTERM signal received: closing HTTP server');
    server.close(() => {
        console.log('HTTP server closed');
    });
});
Step 4: Create the Frontend
index.html
Create the index.html file in the public folder:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat-Bot</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>Chat-Bot</h1>
            <select id="modelSelector"></select>
        </header>
        <div id="chatContainer">
            <div id="chatMessages"></div>
        </div>
        <div id="inputContainer">
            <textarea id="userInput" placeholder="Enter your message..."></textarea>
            <button id="sendButton">Send</button>
        </div>
    </div>
    
    <script src="script.js"></script>
</body>
</html>
styles.css
Create a styles.css file in the public folder to style the chatbot interface:

body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f4;
    margin: 0;
    padding: 0;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}

header {
    text-align: center;
    margin-bottom: 20px;
}

#modelSelector {
    margin-top: 10px;
}

#chatContainer {
    border: 1px solid #ccc;
    padding: 10px;
    background-color: #fff;
    height: 400px;
    overflow-y: scroll;
}

#chatMessages {
    display: flex;
    flex-direction: column;
}

.message {
    margin-bottom: 10px;
    padding: 10px;
    border-radius: 5px;
}

.user-message {
    background-color: #e0f7fa;
    align-self: flex-end;
}

.bot-message {
    background-color: #e0e0e0;
    align-self: flex-start;
}

#inputContainer {
    display: flex;
    margin-top: 20px;
}

#userInput {
    flex: 1;
    padding: 10px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 5px;
}

#sendButton {
    padding: 10px 20px;
    margin-left: 10px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

#sendButton:hover {
    background-color: #0056b3;
}
script.js
Create a script.js file in the public folder to handle the frontend logic:

document.addEventListener('DOMContentLoaded', () => {
    const modelSelector = document.getElementById('modelSelector');
    const chatMessages = document.getElementById('chatMessages');
    const userInput = document.getElementById('userInput');
    const sendButton = document.getElementById('sendButton');

    let selectedModel = '';
    let currentBotMessageElement = null;

    // Fetch available models
    fetchModels();

    modelSelector.addEventListener('change', (e) => {
        selectedModel = e.target.value;
    });

    sendButton.addEventListener('click', sendMessage);
    userInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });

    function fetchModels() {
        fetch('http://localhost:3000/models')
            .then(response => response.json())
            .then(data => {
                if (data.models && Array.isArray(data.models)) {
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.name;
                        option.textContent = model.name;
                        modelSelector.appendChild(option);
                    });
                    selectedModel = data.models[0].name; // Default to the first model
                    modelSelector.value = selectedModel;
                } else {
                    throw new Error('Unexpected format for models data');
                }
            })
            .catch(error => {
                console.error('Error fetching models:', error);
                addMessageToChat('bot', 'Error loading models. Please try again later.', false);
            });
    }

    function sendMessage() {
        const message = userInput.value.trim();
        if (message) {
            addMessageToChat('user', message, true);
            userInput.value = '';

            // Create a new bot message element for this response
            currentBotMessageElement = createMessageElement('bot');
            chatMessages.appendChild(currentBotMessageElement);

            fetch('http://localhost:3000/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    model: selectedModel,
                    messages: [{ role: 'user', content: message }],
                    stream: true
                }),
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                if (response.headers.get('content-type')?.includes('text/event-stream')) {
                    return handleStreamingResponse(response);
                } else {
                    return response.json();
                }
            })
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                // For non-streaming responses
                if (data.response) {
                    updateMessageContent(currentBotMessageElement, data.response, true);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                updateMessageContent(currentBotMessageElement, `Sorry, there was an error: ${error.message}`, false);
            });
        }
    }

    function handleStreamingResponse(response) {
        return new Promise((resolve, reject) => {
            const reader = response.body.getReader();
            let accumulatedContent = '';

            function read() {
                reader.read().then(({ done, value }) => {
                    if (done) {
                        resolve({ response: accumulatedContent });
                        return;
                    }

                    const chunk = new TextDecoder("utf-8").decode(value);
                    const lines = chunk.split('\n');
                    
                    lines.forEach(line => {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.substring(6));
                                if (data.message && data.message.content) {
                                    accumulatedContent += data.message.content;
                                    updateMessageContent(currentBotMessageElement, accumulatedContent, true);
                                }
                            } catch (error) {
                                console.error("Error parsing stream data:", error, line);
                            }
                        }
                    });

                    read();
                }).catch(reject);
            }

            read();
        });
    }

    function createMessageElement(role) {
        const messageElement = document.createElement('div');
        messageElement.classList.add('message', `${role}-message`);
        return messageElement;
    }

    function updateMessageContent(messageElement, content, format = true) {
        if (format) {
            const formattedContent = formatMessage(content);
            messageElement.innerHTML = formattedContent;
        } else {
            messageElement.textContent = DOMPurify.sanitize(content);
        }

        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function formatMessage(content) {
        const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
        let formattedContent = content.replace(codeBlockRegex, (match, language, code) => {
            language = language || 'plaintext';
            const highlightedCode = hljs.highlight(code.trim(), { language: language }).value;
            const escapedCode = DOMPurify.sanitize(highlightedCode);
            return `<pre><div class="code-header"><span class="code-language">${language}</span><button class="copy-button">Copy</button></div><code class="hljs ${language}">${escapedCode}</code></pre>`;
        });

        // Format inline code
        formattedContent = formattedContent.replace(/`([^`\n]+)`/g, '<code>$1</code>');

        // Use marked for the rest of the content
        formattedContent = DOMPurify.sanitize(marked.parse(formattedContent));

        return formattedContent;
    }

    function addMessageToChat(role, content, format = true) {
        const messageElement = createMessageElement(role);
        updateMessageContent(messageElement, content, format);
        chatMessages.appendChild(messageElement);
    }

    // Add event delegation for copy buttons
    chatMessages.addEventListener('click', (e) => {
        if (e.target.classList.contains('copy-button')) {
            const codeElement = e.target.closest('pre').querySelector('code');
            const codeText = codeElement.textContent;

            navigator.clipboard.writeText(codeText)
                .then(() => {
                    e.target.textContent = 'Copied!';
                    setTimeout(() => {
                        e.target.textContent = 'Copy';
                    }, 1500);
                })
                .catch(err => {
                    console.error('Failed to copy code: ', err);
                });
        }
    });
});
also don't forget to add other libraries for this project that is

<link rel="stylesheet" href="src/default.min.css">
<script src="src/highlight.min.js"></script>
<script src="src/marked.min.js"></script>
<script src="src/purify.js"></script>
JavaScript Files:

highlight.min.js:

URL: https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js

<script src="src/highlight.min.js"></script>

This script is used for syntax highlighting of code blocks in your HTML. It’s commonly used with code editors or documentation sites to make code more readable by adding color coding.

marked.min.js:

URL: https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.12/marked.min.js

<script src="src/marked.min.js"></script>

marked.js is a markdown parser. This script converts markdown text into HTML, which allows you to include markdown content in your webpage and render it as formatted HTML.

purify.js:

URL: https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.7/purify.min.js

<script src="src/purify.js"></script>

DOMPurify is a library used to sanitize HTML and prevent XSS (Cross-Site Scripting) attacks. It cleans up user-generated content to ensure it is safe to be inserted into your webpage.